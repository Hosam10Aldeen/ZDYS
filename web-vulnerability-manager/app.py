import time
import sqlite3
import json
from flask import Flask, render_template, request, redirect, url_for, session, send_file, flash
from scanner_api_client import run_scan
from database_manager import init_db, save_scan_result, get_last_scan_results, get_all_results, DB_PATH
from report_generator import generate_pdf
from utils import normalize_output, calculate_cvss, calculate_cvss_from_alerts, level_class
from auth import login_required, login_user, logout_user
from mailer import send_report_email
import os

# Uygulama ve DB başlatma
app = Flask(__name__)
app.secret_key = os.environ.get('FLASK_SECRET_KEY', 'super_secret_key')

# Jinja global fonksiyon
app.jinja_env.globals.update(level_class=level_class)

# Veritabanı tabloları oluştur
init_db()

# Helper: schedules tablosu işlemleri
def get_schedules():
    """
    Aktif veya pasif tüm schedule kayıtlarını getirir.
    Dönüş: list of dict: {'id', 'target', 'tools' (list), 'email', 'interval_minutes', 'enabled'}
    """
    schedules = []
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    try:
        c.execute("SELECT id, target, tools, email, interval_minutes, enabled FROM schedules ORDER BY id ASC")
        rows = c.fetchall()
    except sqlite3.OperationalError:
        # schedules tablosu yoksa []
        conn.close()
        return schedules
    conn.close()
    for row in rows:
        sid, target, tools_json, email, interval, enabled = row
        try:
            tools = json.loads(tools_json)
            if not isinstance(tools, list):
                tools = []
        except Exception:
            tools = []
        schedules.append({
            'id': sid,
            'target': target,
            'tools': tools,
            'email': email,
            'interval_minutes': interval,
            'enabled': bool(enabled)
        })
    return schedules

def create_schedule_entry(target, tools_list, email, interval_minutes):
    """
    schedules tablosuna yeni kayıt ekler. tools_list: Python list of strings.
    """
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute(
        "INSERT INTO schedules (target, tools, email, interval_minutes, enabled) VALUES (?, ?, ?, ?, 1)",
        (target, json.dumps(tools_list), email, interval_minutes)
    )
    conn.commit()
    conn.close()

def delete_schedule_entry(sid):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("DELETE FROM schedules WHERE id = ?", (sid,))
    conn.commit()
    conn.close()

def toggle_schedule_entry(sid):
    """
    enabled sütununu tersine çevirir.
    """
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    # Mevcut değeri oku
    c.execute("SELECT enabled FROM schedules WHERE id = ?", (sid,))
    row = c.fetchone()
    if row:
        current = row[0]
        new = 0 if current == 1 else 1
        c.execute("UPDATE schedules SET enabled = ? WHERE id = ?", (new, sid))
    conn.commit()
    conn.close()

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        if login_user(username, password):
            return redirect(url_for('index'))
        else:
            flash("Geçersiz kullanıcı adı veya şifre.", "error")
    return render_template('login.html')

@app.route('/logout')
def logout():
    logout_user()
    return redirect(url_for('login'))

@app.route('/', methods=['GET', 'POST'])
@login_required
def index():
    """
    GET: anlık tarama formu, zamanlanmış tarama formu, mevcut schedule listesi gösterir.
    POST: form üzerinden gelen action parametresine göre anlık tarama veya schedule oluşturma işlemi yapar.
    """
    if request.method == 'POST':
        action = request.form.get('action')
        if action == 'scan_now':
            # Anlık tarama
            url = request.form.get('url')
            selected_tools = request.form.getlist('tools')
            email = request.form.get('email') or None
            if not url or not selected_tools:
                flash("Lütfen URL girin ve en az bir araç seçin.", "error")
                return redirect(url_for('index'))
            scan_id = int(time.time())
            results = []
            for tool in selected_tools:
                result = run_scan(tool, url)
                if result.get('error'):
                    results.append({"tool": tool, "output": None, "alerts": [], "cvss": 0.0, "error": result.get('error')})
                    # Hata kaydı için veritabanına kaydetmek istersen:
                    save_scan_result(scan_id, url, tool, output=None, alerts_json=None, cvss=0.0)
                    continue
                # Başarılı yanıt
                if tool.lower() == 'zap':
                    alerts = result.get('alerts', [])
                    cvss = calculate_cvss_from_alerts(alerts)
                    save_scan_result(scan_id, url, 'zap', output=None, alerts_json=json.dumps(alerts, ensure_ascii=False), cvss=cvss)
                    results.append({"tool": "zap", "alerts": alerts, "cvss": cvss})
                else:
                    out = normalize_output(result.get('output'))
                    cvss = calculate_cvss(out)
                    save_scan_result(scan_id, url, tool, output=out, alerts_json=None, cvss=cvss)
                    results.append({"tool": tool, "output": out, "cvss": cvss})
            if email:
                try:
                    send_report_email(email, results)
                    flash(f"Tarama tamamlandı ve e-posta gönderildi: {email}", "success")
                except Exception as e:
                    flash(f"Tarama sonucu kaydedildi, ancak e-posta gönderilemedi: {e}", "error")
            return render_template('report.html', results=results)
        elif action == 'create_schedule':
            # Zamanlanmış tarama oluştur
            target = request.form.get('sched_target')
            tools = request.form.getlist('sched_tools')
            email = request.form.get('sched_email') or None
            interval = request.form.get('sched_interval')
            # Validasyon
            if not target or not tools or not interval:
                flash("Lütfen hedef URL, interval ve en az bir araç seçin.", "error")
                return redirect(url_for('index'))
            try:
                interval = int(interval)
                if interval <= 0:
                    raise ValueError
            except:
                flash("Interval pozitif tam sayı olmalı.", "error")
                return redirect(url_for('index'))
            # tools listesi
            create_schedule_entry(target, tools, email, interval)
            flash(f"Yeni zamanlanmış tarama eklendi: {target}, araçlar={tools}, interval={interval} dk.", "success")
            # Not: scheduler.py ayrı süreçte çalışıyorsa, script yeniden başlatıldığında bu ekleme aktif olur.
            return redirect(url_for('index'))
        else:
            # Bilinmeyen action
            flash("Bilinmeyen işlem.", "error")
            return redirect(url_for('index'))

    # GET: gösterim
    schedules = get_schedules()
    return render_template('index.html', schedules=schedules)

@app.route('/schedule/delete/<int:sid>', methods=['POST'])
@login_required
def delete_schedule(sid):
    delete_schedule_entry(sid)
    flash(f"Schedule id={sid} silindi.", "success")
    return redirect(url_for('index'))

@app.route('/schedule/toggle/<int:sid>', methods=['POST'])
@login_required
def toggle_schedule(sid):
    toggle_schedule_entry(sid)
    flash(f"Schedule id={sid} etkinlik durumu değiştirildi.", "success")
    return redirect(url_for('index'))

@app.route('/rapor/pdf')
@login_required
def download_pdf():
    results = get_all_results()
    try:
        filepath = generate_pdf(results)
    except Exception as e:
        return f"PDF oluşturulamadı: {e}", 500
    return send_file(filepath, as_attachment=True)

@app.route('/rapor/pdf/last')
@login_required
def download_last_pdf():
    results = get_last_scan_results()
    try:
        filepath = generate_pdf(results)
    except Exception as e:
        return f"PDF oluşturulamadı: {e}", 500
    return send_file(filepath, as_attachment=True)

if __name__ == '__main__':
    # debug=False üretimde
    app.run(debug=True)



#schedule_form.html
#Ayrı bir terminal veya servis olarak python scheduler.py çalıştırın.
#Scheduler, schedules tablosundaki enabled=1 kayıtları okuyacak ve job ekleyecek.
#Yeni eklediğiniz schedule’lerin aktif olabilmesi için scheduler script’ini yeniden
#başlatmanız gerekebilir (basit sürüm). Alternatif olarak daha dinamik APScheduler
#entegrasyonu yapabilirsiniz