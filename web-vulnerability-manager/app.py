# app.py
import time
import sqlite3
import json
import sys
import os
from flask import Flask, render_template, request, redirect, url_for, session, send_file, flash, jsonify
from scanner_api_client import run_scan
from database_manager import init_db, save_scan_result, get_user_all_results, get_user_last_scan_results, create_user, get_user_by_id, DB_PATH
from report_generator import generate_pdf
from utils import normalize_output, calculate_cvss, calculate_cvss_from_alerts, level_class
from auth import login_required, login_user, logout_user
from mailer import send_report_email
from urllib.parse import urlparse
import re
import requests

NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cve/1.0/"

app = Flask(__name__)
app.secret_key = os.environ.get('FLASK_SECRET_KEY', 'super_secret_key')
app.jinja_env.globals.update(level_class=level_class)

# Veritabanı tabloları oluştur
init_db()

# Kullanıcı kayıt route
@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form.get('username').strip()
        password = request.form.get('password')
        password2 = request.form.get('password2')
        if not username or not password or not password2:
            flash("Lütfen tüm alanları doldurun.", "error")
            return render_template('register.html')
        if password != password2:
            flash("Şifreler uyuşmuyor.", "error")
            return render_template('register.html')
        # Yeni kullanıcı oluştur
        user_id = create_user(username, password)
        if not user_id:
            flash("Bu kullanıcı adı zaten alınmış.", "error")
            return render_template('register.html')
        flash("Kayıt başarılı. Lütfen giriş yapın.", "success")
        return redirect(url_for('login'))
    return render_template('register.html')

# Giriş route
@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form.get('username').strip()
        password = request.form.get('password')
        if login_user(username, password):
            flash(f"Hoşgeldin, {username}.", "success")
            return redirect(url_for('index'))
        else:
            flash("Geçersiz kullanıcı adı veya şifre.", "error")
    return render_template('login.html')

# Logout
@app.route('/logout')
def logout():
    logout_user()
    flash("Çıkış yapıldı.", "success")
    return redirect(url_for('login'))

# Helper: schedules işlemleri kullanıcı bazlı
def get_schedules_for_user(user_id):
    """
    Kullanıcının tüm schedule kayıtlarını getirir.
    Dönüş: list of dict: {'id', 'target', 'tools' (list), 'email', 'interval_minutes', 'enabled'}
    """
    schedules = []
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    try:
        c.execute("SELECT id, target, tools, email, interval_minutes, enabled FROM schedules WHERE user_id = ? ORDER BY id ASC", (user_id,))
        rows = c.fetchall()
    except sqlite3.OperationalError:
        conn.close()
        return schedules
    conn.close()
    for row in rows:
        sid, target, tools_json, email, interval, enabled = row
        try:
            tools = json.loads(tools_json)
            if not isinstance(tools, list):
                tools = []
        except Exception:
            tools = []
        schedules.append({
            'id': sid,
            'target': target,
            'tools': tools,
            'email': email,
            'interval_minutes': interval,
            'enabled': bool(enabled)
        })
    return schedules

def create_schedule_entry(user_id, target, tools_list, email, interval_minutes):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute(
        "INSERT INTO schedules (target, tools, email, interval_minutes, enabled, user_id) VALUES (?, ?, ?, ?, 1, ?)",
        (target, json.dumps(tools_list), email, interval_minutes, user_id)
    )
    conn.commit()
    conn.close()

def delete_schedule_entry(user_id, sid):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    # Sadece kendi kullanıcısının kaydı silinebilsin:
    c.execute("DELETE FROM schedules WHERE id = ? AND user_id = ?", (sid, user_id))
    conn.commit()
    conn.close()

def toggle_schedule_entry(user_id, sid):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    # Sadece kendi kullanıcısının kaydı güncellenir:
    c.execute("SELECT enabled FROM schedules WHERE id = ? AND user_id = ?", (sid, user_id))
    row = c.fetchone()
    if row:
        current = row[0]
        new = 0 if current == 1 else 1
        c.execute("UPDATE schedules SET enabled = ? WHERE id = ? AND user_id = ?", (new, sid, user_id))
    conn.commit()
    conn.close()

# Anasayfa: anlık tarama ve schedule yönetimi
@app.route('/', methods=['GET', 'POST'])
@login_required
def index():
    user_id = session.get('user_id')
    username = session.get('username')
    if request.method == 'POST':
        action = request.form.get('action')
        if action == 'scan_now':
            url = request.form.get('url')
            selected_tools = request.form.getlist('tools')
            email = request.form.get('email') or None
            if not url or not selected_tools:
                flash("Lütfen URL girin ve en az bir araç seçin.", "error")
                return redirect(url_for('index'))
            scan_id = int(time.time())
            results = []
            for tool in selected_tools:
                result = run_scan(tool, url)
                if result.get('error'):
                    results.append({"tool": tool, "output": None, "alerts": [], "cvss": 0.0, "error": result.get('error')})
                    # Hata kaydı da sakla
                    save_scan_result(scan_id, url, tool, output=None, alerts_json=None, cvss=0.0, user_id=user_id)
                    continue
                if tool.lower() == 'zap':
                    alerts = result.get('alerts', [])
                    cvss = calculate_cvss_from_alerts(alerts)
                    save_scan_result(scan_id, url, 'zap', output=None, alerts_json=json.dumps(alerts, ensure_ascii=False), cvss=cvss, user_id=user_id)
                    results.append({"tool": "zap", "alerts": alerts, "cvss": cvss})
                else:
                    out = normalize_output(result.get('output'))
                    cvss = calculate_cvss(out)
                    save_scan_result(scan_id, url, tool, output=out, alerts_json=None, cvss=cvss, user_id=user_id)
                    results.append({"tool": tool, "output": out, "cvss": cvss})
            if email:
                try:
                    send_report_email(email, results)
                    flash(f"Tarama tamamlandı ve e-posta gönderildi: {email}", "success")
                except Exception as e:
                    flash(f"Tarama sonucu kaydedildi, ancak e-posta gönderilemedi: {e}", "error")
            return render_template('report.html', results=results, username=username)
        elif action == 'create_schedule':
            target = request.form.get('sched_target')
            tools = request.form.getlist('sched_tools')
            email = request.form.get('sched_email') or None
            interval = request.form.get('sched_interval')
            if not target or not tools or not interval:
                flash("Lütfen hedef URL, interval ve en az bir araç seçin.", "error")
                return redirect(url_for('index'))
            try:
                interval = int(interval)
                if interval <= 0:
                    raise ValueError
            except:
                flash("Interval pozitif tam sayı olmalı.", "error")
                return redirect(url_for('index'))
            create_schedule_entry(user_id, target, tools, email, interval)
            flash(f"Yeni zamanlanmış tarama eklendi: {target}, araçlar={tools}, interval={interval} dk.", "success")
            return redirect(url_for('index'))
        else:
            flash("Bilinmeyen işlem.", "error")
            return redirect(url_for('index'))

    # GET: verileri hazırla
    schedules = get_schedules_for_user(user_id)
    # Kullanıcının geçmiş taramaları listesi isteğe bağlı index'te gösterilebilir
    return render_template('index.html', schedules=schedules, username=username)


def enrich_cves(cve_list):
    """
    CVE listesi için NVD API’den detay al. Döner: list of dict:
    { "cve_id":..., "description":..., "cvss":..., "risk":..., "references": [...], "solution": ... }
    """
    results = []
    for cve_id in sorted(set(cve_list)):
        url = NVD_API_URL + cve_id
        try:
            resp = requests.get(url, timeout=10)
            if resp.status_code != 200:
                # API hatası; en azından CVE ID döndür
                results.append({"cve_id": cve_id, "error": f"NVD API status {resp.status_code}"})
                continue
            data = resp.json()
            items = data.get("result", {}).get("CVE_Items", [])
            if not items:
                results.append({"cve_id": cve_id, "error": "No CVE data found"})
                continue
            item = items[0]
            # Açıklama
            desc_data = item.get("cve", {}).get("description", {}).get("description_data", [])
            description = desc_data[0].get("value") if desc_data else ""
            # CVSS v3
            impact = item.get("impact", {})
            cvss = None
            if "baseMetricV3" in impact:
                cvss = impact["baseMetricV3"]["cvssV3"].get("baseScore")
            elif "baseMetricV2" in impact:
                cvss = impact["baseMetricV2"]["cvssV2"].get("baseScore")
            # Risk seviyesi
            risk = None
            if isinstance(cvss, (int, float)):
                if cvss >= 9.0:
                    risk = "Critical"
                elif cvss >= 7.0:
                    risk = "High"
                elif cvss >= 4.0:
                    risk = "Medium"
                else:
                    risk = "Low"
            # References: liste halinde URL’ler
            refs = []
            ref_data = item.get("cve", {}).get("references", {}).get("reference_data", [])
            for r in ref_data:
                url_ref = r.get("url")
                if url_ref:
                    refs.append(url_ref)
            # Çözüm önerisi: NVD’de doğrudan yok; references içinden vendor advisory veya Mitre sayfası olabilir.
            # Basit öneri:
            if refs:
                solution = f"Lütfen vendor advisory ve referansları kontrol edin: {refs[0]}"
            else:
                solution = ""
            results.append({
                "cve_id": cve_id,
                "description": description,
                "cvss": cvss,
                "risk": risk,
                "references": refs,
                "solution": solution
            })
            # Opsiyonel: Rate limit için kısa bekleme
            time.sleep(0.6)
        except Exception as e:
            results.append({"cve_id": cve_id, "error": str(e)})
    return results

@app.route('/scan_tool', methods=['POST'])
@login_required
def scan_tool():
    from urllib.parse import urlparse
    data = request.get_json()
    if not data:
        return jsonify({"error": "No JSON payload"}), 400
    tool = data.get('tool')
    target = data.get('target')
    scan_id = data.get('scan_id') or int(time.time())
    if not tool or not target:
        return jsonify({"tool": tool or "unknown", "error": "tool veya target eksik"}), 400

    # URL normalize/doğrulama
    raw = target.strip()
    parsed = urlparse(raw)
    if not parsed.scheme:
        raw = 'http://' + raw
        parsed = urlparse(raw)
    if not parsed.netloc:
        return jsonify({"tool": tool, "error": "Invalid URL format"}), 400
    target_norm = raw

    user_id = session.get('user_id')

    # Gerçek tarama
    result = run_scan(tool, target_norm)
    if result.get('error'):
        save_scan_result(scan_id, target_norm, tool, output=None, alerts_json=None, cvss=0.0, user_id=user_id)
        return jsonify({"tool": tool, "error": result.get('error')})

    # ZAP
    if tool.lower() == 'zap':
        alerts = result.get('alerts', [])
        enriched_alerts = []
        for alert in alerts:
            # alert dict içinden name, risk, description, solution varsa doğrudan al
            enriched_alerts.append({
                "name": alert.get("name"),
                "risk": alert.get("risk"),
                "description": alert.get("description"),
                "solution": alert.get("solution"),
                # istersen URL vb. ekleyebilirsin:
                "reference": alert.get("reference"),
                "cweid": alert.get("cweid")
            })
        cvss = calculate_cvss_from_alerts(alerts)
        save_scan_result(scan_id, target_norm, 'zap', output=None,
                         alerts_json=json.dumps(alerts, ensure_ascii=False),
                         cvss=cvss, user_id=user_id)
        return jsonify({"tool":"zap", "alerts": enriched_alerts, "cvss": cvss})

    # WPScan
    if tool.lower() == 'wpscan':
        vulns = result.get('vulnerabilities', [])
        # result zaten Kali API’de parse edilmiş vulnerabilities döndürdüyse, direkt iletebiliriz.
        # CVSS bilgisi olmayabilir; istersen her vulnerability için CVE ID’leri varsa enrich_cves çağr:
        enriched = []
        for v in vulns:
            entry = {
                "component": v.get("component"),
                "name": v.get("name"),
                "title": v.get("title"),
                "description": v.get("description"),
                "fixed_in": v.get("fixed_in"),
                "references": v.get("references"),
                "cve": v.get("cve")
            }
            # Eğer v["cve"] listesinde CVE ID varsa, bunları NVD API’den detayla zenginle:
            cves = v.get("cve") or []
            if cves:
                entry["cve_details"] = enrich_cves(cves)
            enriched.append(entry)
        # Kaydetme: stringleştirilmiş JSON saklayalım
        save_scan_result(scan_id, target_norm, 'wpscan',
                         output=None,
                         alerts_json=json.dumps(enriched, ensure_ascii=False),
                         cvss=0.0,  # WPScan’dan genel cvss çıkarımı otomatik değil
                         user_id=user_id)
        return jsonify({"tool":"wpscan", "vulnerabilities": enriched})

    # Diğer araçlar: nmap, nikto
    out = result.get('output') or ''
    # 1) DB kaydı raw output
    save_scan_result(scan_id, target_norm, tool, output=out, alerts_json=None, cvss=calculate_cvss(out), user_id=user_id)

    # 2) CVE ID extract
    cve_list = re.findall(r"CVE-\d{4}-\d{4,7}", out, flags=re.IGNORECASE)
    cve_list = [cve.upper() for cve in cve_list]
    cve_details = []
    if cve_list:
        try:
            cve_details = enrich_cves(cve_list)
        except Exception as e:
            # Eğer NVD API erişim hatası vs:
            cve_details = [{"error": f"CVE lookup error: {e}"}]
    # 3) Risk seviyesi: Burada genel bir risk belirlemek zor; istersen en yüksek CVSS değerine bak:
    overall_cvss = calculate_cvss(out)
    overall_risk = None
    if isinstance(overall_cvss, (int, float)):
        if overall_cvss >= 9.0:
            overall_risk = "Critical"
        elif overall_cvss >= 7.0:
            overall_risk = "High"
        elif overall_cvss >= 4.0:
            overall_risk = "Medium"
        else:
            overall_risk = "Low"
    return jsonify({
        "tool": tool,
        "output": out,
        "cvss": overall_cvss,
        "risk": overall_risk,
        "cve_ids": sorted(set(cve_list)),
        "cve_details": cve_details
    })
        # nmap/nikto kısmında after cve_details:
      



# AJAX endpoint: e-posta gönderimi
@app.route('/send_email', methods=['POST'])
@login_required
def send_email():
    """
    AJAX ile tüm sonuçlar toplandıktan sonra çağrılır.
    JSON payload: { "email": "user@example.com", "results": [ {tool, output/alerts, cvss, maybe error}, ... ] }
    """
    data = request.get_json()
    if not data:
        return jsonify({"error": "No JSON payload"}), 400
    email = data.get('email')
    results = data.get('results')
    if not email or not isinstance(results, list):
        return jsonify({"error": "email veya results eksik veya geçersiz"}), 400
    try:
        send_report_email(email, results)
        return jsonify({"status": "ok"})
    except Exception as e:
        # Loglama
        print(f"[send_email] Error sending email: {e}")
        return jsonify({"error": f"E-posta gönderilemedi: {e}"}), 500

# Diğer route'lar (PDF indirme, schedule silme/toggle vs.) burada kalacak...

# Schedule silme
@app.route('/schedule/delete/<int:sid>', methods=['POST'])
@login_required
def delete_schedule(sid):
    user_id = session.get('user_id')
    delete_schedule_entry(user_id, sid)
    flash(f"Schedule id={sid} silindi.", "success")
    return redirect(url_for('index'))

# Schedule toggle
@app.route('/schedule/toggle/<int:sid>', methods=['POST'])
@login_required
def toggle_schedule(sid):
    user_id = session.get('user_id')
    toggle_schedule_entry(user_id, sid)
    flash(f"Schedule id={sid} etkinlik durumu değiştirildi.", "success")
    return redirect(url_for('index'))

# PDF indirme: sadece kullanıcının kendi sonuçları
@app.route('/rapor/pdf')
@login_required
def download_pdf():
    user_id = session.get('user_id')
    results = get_user_all_results(user_id)
    try:
        filepath = generate_pdf(results)
    except Exception as e:
        return f"PDF oluşturulamadı: {e}", 500
    return send_file(filepath, as_attachment=True)

@app.route('/rapor/pdf/last')
@login_required
def download_last_pdf():
    user_id = session.get('user_id')
    results = get_user_last_scan_results(user_id)
    try:
        filepath = generate_pdf(results)
    except Exception as e:
        return f"PDF oluşturulamadı: {e}", 500
    return send_file(filepath, as_attachment=True)

@app.route('/rapor/list')
@login_required
def list_reports():
    user_id = session.get('user_id')
    results = get_user_all_results(user_id)
    return render_template('report_list.html', results=results, username=session.get('username'))

if __name__ == '__main__':
    app.run(debug=True)
