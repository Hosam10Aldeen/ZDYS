# kali_api_server.py
from flask import Flask, request, jsonify
import subprocess
import time
import requests
import urllib.parse

app = Flask(__name__)

def run_subprocess_cmd(cmd_list, timeout_sec=120):
    try:
        completed = subprocess.run(cmd_list, capture_output=True, text=True, timeout=timeout_sec)
        return completed.stdout + completed.stderr
    except subprocess.TimeoutExpired:
        return f"Command {' '.join(cmd_list)} timed out after {timeout_sec}s"
    except Exception as e:
        return f"Command execution error: {e}"

@app.route('/scan/nmap', methods=['POST'])
def nmap_scan():
    target = request.json.get('target')
    if not target:
        return jsonify({"tool": "nmap", "error": "No target provided"}), 400
    output = run_subprocess_cmd(["nmap", "-sV", target], timeout_sec=120)
    return jsonify({"tool": "nmap", "output": output})

@app.route('/scan/nikto', methods=['POST'])
def nikto_scan():
    target = request.json.get('target')
    if not target:
        return jsonify({"tool": "nikto", "error": "No target provided"}), 400
    output = run_subprocess_cmd(["nikto", "-h", target], timeout_sec=300)
    return jsonify({"tool": "nikto", "output": output})

@app.route('/scan/wpscan', methods=['POST'])
def wpscan_scan():
    target = request.json.get('target')
    if not target:
        return jsonify({"tool": "wpscan", "error": "No target provided"}), 400
    output = run_subprocess_cmd(["wpscan", "--url", target], timeout_sec=300)
    return jsonify({"tool": "wpscan", "output": output})

@app.route('/scan/zap', methods=['POST'])
def zap_scan():
    target = request.json.get('target')
    if not target:
        return jsonify({"tool": "zap", "error": "No target provided"}), 400

    parsed = urllib.parse.urlparse(target)
    if parsed.scheme not in ('http', 'https') or not parsed.netloc:
        return jsonify({"tool": "zap", "error": "Invalid URL format"}), 400

    zap_base = "http://127.0.0.1:8090"

    # Context ayarları (örn. ctx_example.com)
    domain = parsed.netloc.replace('.', r'\.')
    context_name = f"ctx_{parsed.netloc}"
    regex_include = f"^https?://{domain}.*"
    try:
        requests.get(f"{zap_base}/JSON/context/action/newContext/?contextName={context_name}", timeout=5)
        requests.get(f"{zap_base}/JSON/context/action/includeInContext/?contextName={context_name}&regex={urllib.parse.quote(regex_include, safe='')}", timeout=5)
        exclude_regex = f"^https?://(?!{domain}).*"
        requests.get(f"{zap_base}/JSON/context/action/excludeFromContext/?contextName={context_name}&regex={urllib.parse.quote(exclude_regex, safe='')}", timeout=5)
    except Exception:
        pass

    # Access URL
    try:
        requests.get(f"{zap_base}/JSON/core/action/accessUrl/?url={urllib.parse.quote(target, safe='')}", timeout=5)
        time.sleep(2)
    except Exception:
        pass

    # Start active scan
    try:
        scan_resp = requests.get(f"{zap_base}/JSON/ascan/action/scan/?url={urllib.parse.quote(target, safe='')}&recurse=true&contextName={context_name}", timeout=10)
    except requests.RequestException as e:
        return jsonify({"tool": "zap", "error": f"Failed to start scan: {e}"}), 500

    if scan_resp.status_code != 200:
        return jsonify({"tool": "zap", "error": f"Failed to start scan, status={scan_resp.status_code}"}), 500
    scan_data = scan_resp.json()
    scan_id = scan_data.get('scan')
    if not scan_id:
        return jsonify({"tool": "zap", "error": "ScanId not returned"}), 500

    # Wait for completion with timeout
    MAX_WAIT = 600
    start_time = time.time()
    while True:
        time.sleep(2)
        try:
            status_resp = requests.get(f"{zap_base}/JSON/ascan/view/status/?scanId={scan_id}", timeout=5)
        except requests.RequestException as e:
            return jsonify({"tool": "zap", "error": f"Status request failed: {e}"}), 500
        if status_resp.status_code != 200:
            return jsonify({"tool": "zap", "error": f"Status request HTTP {status_resp.status_code}"}), 500
        status = status_resp.json().get('status')
        if status == '100':
            break
        if time.time() - start_time > MAX_WAIT:
            return jsonify({"tool": "zap", "error": f"Scan timeout after {MAX_WAIT}s"}), 500

    # Get alerts JSON
    try:
        alerts_resp = requests.get(f"{zap_base}/JSON/core/view/alerts/?baseurl={urllib.parse.quote(target, safe='')}", timeout=10)
    except requests.RequestException as e:
        return jsonify({"tool": "zap", "error": f"Fetching alerts failed: {e}"}), 500
    if alerts_resp.status_code != 200:
        return jsonify({"tool": "zap", "error": f"Alerts HTTP {alerts_resp.status_code}"}), 500
    alerts = alerts_resp.json().get('alerts', [])
    return jsonify({"tool": "zap", "alerts": alerts})

if __name__ == '__main__':
    # ZAP daemon'ı zaten başlatılmış olmalı:
    # zaproxy -daemon -port 8090 -host 127.0.0.1 -config api.disablekey=true
    app.run(host='0.0.0.0', port=5000)