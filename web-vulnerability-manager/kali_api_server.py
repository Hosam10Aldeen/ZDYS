# kali_api_server.py
from flask import Flask, request, jsonify
import subprocess
import time
import requests
import urllib.parse

app = Flask(__name__)

def run_subprocess_cmd(cmd_list, timeout_sec=120):
    try:
        completed = subprocess.run(cmd_list, capture_output=True, text=True, timeout=timeout_sec)
        return completed.stdout + completed.stderr
    except subprocess.TimeoutExpired:
        return f"Command {' '.join(cmd_list)} timed out after {timeout_sec}s"
    except Exception as e:
        return f"Command execution error: {e}"

@app.route('/scan/nmap', methods=['POST'])
def nmap_scan():
    target = request.json.get('target')
    if not target:
        return jsonify({"tool": "nmap", "error": "No target provided"}), 400
    output = run_subprocess_cmd(["nmap", "-sV", target], timeout_sec=120)
    return jsonify({"tool": "nmap", "output": output})

@app.route('/scan/nikto', methods=['POST'])
def nikto_scan():
    target = request.json.get('target')
    if not target:
        return jsonify({"tool": "nikto", "error": "No target provided"}), 400
    output = run_subprocess_cmd(["nikto", "-h", target], timeout_sec=300)
    return jsonify({"tool": "nikto", "output": output})

@app.route('/scan/wpscan', methods=['POST'])
def wpscan_scan():
    import subprocess, json
    target = request.json.get('target')
    if not target:
        return jsonify({"tool":"wpscan","error":"No target provided"}), 400
    # Örnek: --format json ile JSON çıktıyı al
    # --no-update eklenebilir veya isteğe göre güncelleme yapılabilir
    cmd = ["wpscan", "--url", target, "--format", "json", "--no-update"]
    try:
        completed = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
        output = completed.stdout
        # Eğer stderr’de hata varsa da kaydedebiliriz:
        if completed.returncode != 0 and not output:
            return jsonify({"tool":"wpscan","error": f"WPScan error: {completed.stderr.strip()}"}), 500
    except subprocess.TimeoutExpired:
        return jsonify({"tool":"wpscan","error":f"WPScan command timed out"}), 500
    except Exception as e:
        return jsonify({"tool":"wpscan","error":f"WPScan execution error: {e}"}), 500

    # JSON parse
    try:
        data = json.loads(output)
    except Exception:
        # JSON parse edilemediyse raw çıktıyı dön
        return jsonify({"tool":"wpscan","output": output})

    # WPScan JSON yapısı, genelde "vulnerable_plugins", "vulnerable_themes", "version" vb. içerir.
    vulnerabilities = []
    # Örnek plugin zafiyetleri:
    for key in ("vulnerable_plugins", "vulnerable_themes"):
        items = data.get(key, {})
        # WPScan JSON: items bir dict, her plugin adı bir key, value içinde "vulnerabilities" listesi var
        if isinstance(items, dict):
            for name, info in items.items():
                vulns = info.get("vulnerabilities") or []
                for v in vulns:
                    # v tipik olarak dict: { "title":..., "references":{...}, "fixed_in":..., "cve": [...], "url":... }
                    entry = {
                        "component": key.replace("vulnerable_", ""),  # "plugins" veya "themes"
                        "name": name,
                        "title": v.get("title") or "",
                        "description": v.get("description") or "",
                        "fixed_in": v.get("fixed_in") or "",
                        "references": v.get("references") or {},
                        "cve": v.get("cve") or []
                    }
                    vulnerabilities.append(entry)
    # Ayrıca core WordPress zafiyetleri varsa:
    core_vulns = data.get("version", {}).get("vulnerabilities") or []
    for v in core_vulns:
        entry = {
            "component": "core",
            "name": data.get("version", {}).get("number",""),
            "title": v.get("title") or "",
            "description": v.get("description") or "",
            "fixed_in": v.get("fixed_in") or "",
            "references": v.get("references") or {},
            "cve": v.get("cve") or []
        }
        vulnerabilities.append(entry)

    # Eğer vulnerabilities boşsa, raw output da dönülebilir:
    return jsonify({"tool":"wpscan", "vulnerabilities": vulnerabilities})


@app.route('/scan/zap', methods=['POST'])
def zap_scan():
    target = request.json.get('target')
    if not target:
        return jsonify({"tool": "zap", "error": "No target provided"}), 400

    parsed = urllib.parse.urlparse(target)
    if parsed.scheme not in ('http', 'https') or not parsed.netloc:
        return jsonify({"tool": "zap", "error": "Invalid URL format"}), 400

    zap_base = "http://127.0.0.1:8090"

    # Context ayarları (örn. ctx_example.com)
    domain = parsed.netloc.replace('.', r'\.')
    context_name = f"ctx_{parsed.netloc}"
    regex_include = f"^https?://{domain}.*"
    try:
        requests.get(f"{zap_base}/JSON/context/action/newContext/?contextName={context_name}", timeout=5)
        requests.get(f"{zap_base}/JSON/context/action/includeInContext/?contextName={context_name}&regex={urllib.parse.quote(regex_include, safe='')}", timeout=5)
        exclude_regex = f"^https?://(?!{domain}).*"
        requests.get(f"{zap_base}/JSON/context/action/excludeFromContext/?contextName={context_name}&regex={urllib.parse.quote(exclude_regex, safe='')}", timeout=5)
    except Exception:
        pass

    # Access URL
    try:
        requests.get(f"{zap_base}/JSON/core/action/accessUrl/?url={urllib.parse.quote(target, safe='')}", timeout=5)
        time.sleep(2)
    except Exception:
        pass

    # Start active scan
    try:
        scan_resp = requests.get(f"{zap_base}/JSON/ascan/action/scan/?url={urllib.parse.quote(target, safe='')}&recurse=true&contextName={context_name}", timeout=10)
    except requests.RequestException as e:
        return jsonify({"tool": "zap", "error": f"Failed to start scan: {e}"}), 500

    if scan_resp.status_code != 200:
        return jsonify({"tool": "zap", "error": f"Failed to start scan, status={scan_resp.status_code}"}), 500
    scan_data = scan_resp.json()
    scan_id = scan_data.get('scan')
    if not scan_id:
        return jsonify({"tool": "zap", "error": "ScanId not returned"}), 500

    # Wait for completion with timeout
    MAX_WAIT = 600
    start_time = time.time()
    while True:
        time.sleep(2)
        try:
            status_resp = requests.get(f"{zap_base}/JSON/ascan/view/status/?scanId={scan_id}", timeout=5)
        except requests.RequestException as e:
            return jsonify({"tool": "zap", "error": f"Status request failed: {e}"}), 500
        if status_resp.status_code != 200:
            return jsonify({"tool": "zap", "error": f"Status request HTTP {status_resp.status_code}"}), 500
        status = status_resp.json().get('status')
        if status == '100':
            break
        if time.time() - start_time > MAX_WAIT:
            return jsonify({"tool": "zap", "error": f"Scan timeout after {MAX_WAIT}s"}), 500

    # Get alerts JSON
    try:
        alerts_resp = requests.get(f"{zap_base}/JSON/core/view/alerts/?baseurl={urllib.parse.quote(target, safe='')}", timeout=10)
    except requests.RequestException as e:
        return jsonify({"tool": "zap", "error": f"Fetching alerts failed: {e}"}), 500
    if alerts_resp.status_code != 200:
        return jsonify({"tool": "zap", "error": f"Alerts HTTP {alerts_resp.status_code}"}), 500
    alerts = alerts_resp.json().get('alerts', [])
    return jsonify({"tool": "zap", "alerts": alerts})

if __name__ == '__main__':
    # ZAP daemon'ı zaten başlatılmış olmalı:
    # zaproxy -daemon -port 8090 -host 127.0.0.1 -config api.disablekey=true
    app.run(host='0.0.0.0', port=5000)
