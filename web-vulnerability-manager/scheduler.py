# scheduler.py
import sqlite3
import json
import time
import traceback
from datetime import datetime
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.interval import IntervalTrigger
from scanner_api_client import run_scan
from database_manager import DB_PATH, save_scan_result
from utils import normalize_output, calculate_cvss, calculate_cvss_from_alerts
from mailer import send_report_email

scheduler = BackgroundScheduler()
active_job_ids = set()

def get_schedules_from_db():
    """
    schedules tablosundan tüm kayıtları alır (user_id, enabled dahil).
    Dönüş: list of dict:
      {
        'id': int,
        'target': str,
        'tools': [str,...],
        'email': str or None,
        'interval_minutes': int,
        'enabled': int (0/1),
        'user_id': int
      }
    """
    schedules = []
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    try:
        c.execute("SELECT id, target, tools, email, interval_minutes, enabled, user_id FROM schedules")
        rows = c.fetchall()
    except Exception as e:
        print("Error reading schedules table:", e)
        conn.close()
        return schedules
    conn.close()

    for row in rows:
        sid, target, tools_json, email, interval, enabled, user_id = row
        # tools_json parse
        try:
            tools = json.loads(tools_json)
            if not isinstance(tools, list):
                raise ValueError
        except Exception:
            print(f"[scheduler] Invalid tools JSON for schedule id={sid}: {tools_json}. Atlanıyor.")
            continue
        # basic validation
        if not target or not isinstance(interval, int) or interval <= 0:
            print(f"[scheduler] Skipping invalid schedule id={sid}: target={target}, interval={interval}")
            continue
        schedules.append({
            'id': sid,
            'target': target,
            'tools': tools,
            'email': email,
            'interval_minutes': interval,
            'enabled': enabled,
            'user_id': user_id
        })
    return schedules

def run_scheduled_scan(schedule):
    """
    Tek bir schedule girdisi için taramayı çalıştırır ve sonucu ilgili user_id ile kaydeder.
    schedule: dict:
      {
        'id': int,
        'target': str,
        'tools': [str,...],
        'email': str or None,
        'interval_minutes': int,
        'user_id': int,
        'enabled': int
      }
    """
    sid = schedule['id']
    target = schedule['target']
    tools = schedule['tools']
    email = schedule.get('email')
    user_id = schedule.get('user_id')
    scan_id = int(time.time())
    print(f"[{datetime.now().isoformat()}] Running scheduled scan id={sid}, target={target}, tools={tools}, user_id={user_id}")
    results = []

    for tool in tools:
        try:
            result = run_scan(tool, target)
        except Exception as e:
            print(f"[scheduler] Error calling run_scan for tool={tool}, target={target}: {e}")
            traceback.print_exc()
            result = {'tool': tool, 'error': f"Exception in run_scan: {e}"}

        if result.get('error'):
            # Hata durumu: yine de kaydet, user_id ile
            save_scan_result(scan_id, target, tool, output=None, alerts_json=None, cvss=0.0, user_id=user_id)
            results.append({"tool": tool, "output": None, "alerts": [], "cvss": 0.0, "error": result.get('error')})
            continue

        # Başarılı yanıt
        if tool.lower() == 'zap':
            alerts = result.get('alerts', [])
            cvss = calculate_cvss_from_alerts(alerts)
            save_scan_result(scan_id, target, 'zap', output=None,
                             alerts_json=json.dumps(alerts, ensure_ascii=False),
                             cvss=cvss, user_id=user_id)
            results.append({"tool": "zap", "alerts": alerts, "cvss": cvss})
        else:
            out = normalize_output(result.get('output'))
            cvss = calculate_cvss(out)
            save_scan_result(scan_id, target, tool, output=out, alerts_json=None, cvss=cvss, user_id=user_id)
            results.append({"tool": tool, "output": out, "cvss": cvss})

    # E-posta bildirimi
    if email:
        try:
            print(f"[{datetime.now().isoformat()}] Sending email to {email} for schedule id={sid}")
            send_report_email(email, results)
        except Exception as e:
            print(f"[scheduler] Error sending email for schedule id={sid}, email={email}: {e}")
            traceback.print_exc()

def sync_jobs():
    """
    Veritabanındaki schedule kayıtlarını kontrol eder:
      - enabled=1 ve henüz scheduler'da yoksa job ekler
      - enabled=0 veya silinmiş schedule job'larını scheduler'dan kaldırır
    """
    global active_job_ids
    schedules = get_schedules_from_db()
    desired_job_ids = set()  # DB'de olması gereken job id'leri

    # 1) DB'deki kayıtlara göre ekleme veya disabled duruma göre kaldırma
    for sched in schedules:
        job_id = f"schedule_{sched['id']}"
        desired_job_ids.add(job_id)

        if sched['enabled'] == 1 and job_id not in active_job_ids:
            # Yeni job ekle
            try:
                scheduler.add_job(
                    run_scheduled_scan,
                    trigger=IntervalTrigger(minutes=sched['interval_minutes']),
                    args=[sched],
                    id=job_id,
                    name=f"Schedule {sched['id']} target={sched['target']} user={sched.get('user_id', 'N/A')}",
                    replace_existing=True
                )
                print(f"[scheduler] Added job id={job_id}, interval={sched['interval_minutes']} dk, target={sched['target']}")
            except Exception as e:
                print(f"[scheduler] Failed to add job for schedule id={sched['id']}: {e}")
        elif sched['enabled'] == 0 and job_id in active_job_ids:
            # Pasif yapılmış job'ı kaldır
            try:
                scheduler.remove_job(job_id)
                print(f"[scheduler] Removed job id={job_id} (disabled)")
            except Exception as e:
                print(f"[scheduler] Failed to remove job {job_id}: {e}")

    # 2) Silinmiş schedule’lar: scheduler’da olup DB'de artık olmayan job’ları kaldır
    for job in scheduler.get_jobs():
        jid = job.id
        # sync_job id’si hariç
        if jid == "sync_job":
            continue
        # Eğer job bir schedule job ise ve desired_job_ids içinde değilse sil
        if jid.startswith("schedule_") and jid not in desired_job_ids:
            try:
                scheduler.remove_job(jid)
                print(f"[scheduler] Removed job id={jid} (schedule deleted)")
            except Exception as e:
                print(f"[scheduler] Failed to remove deleted schedule job {jid}: {e}")

    # 3) active_job_ids güncelle
    active_job_ids = set(job.id for job in scheduler.get_jobs())

def main():
    print("[scheduler] Starting dynamic scheduler...")
    # Her 10 saniyede bir sync_jobs ile veritabanını kontrol et
    scheduler.add_job(sync_jobs, trigger=IntervalTrigger(seconds=10), id="sync_job", replace_existing=True)
    # Başlangıçta hemen çalıştır, böylece script ilk başlatıldığında kayıtlı enabled=1 job'lar eklenir
    sync_jobs()
    scheduler.start()

    try:
        while True:
            time.sleep(10)
    except (KeyboardInterrupt, SystemExit):
        print("[scheduler] Scheduler durduruluyor...")
        scheduler.shutdown()

if __name__ == '__main__':
    main()
