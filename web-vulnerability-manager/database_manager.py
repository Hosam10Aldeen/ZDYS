# database_manager.py
import sqlite3
import json
from datetime import datetime
from werkzeug.security import generate_password_hash, check_password_hash

DB_PATH = 'database.db'

def init_db():
    """
    Veritabanı tablolarını oluşturur veya var olan tabloya gerekli sütun eklemelerini yapar.
    """
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()

    # 1. users tablosu
    c.execute('''
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT UNIQUE NOT NULL,
            password_hash TEXT NOT NULL,
            created_at TEXT NOT NULL
        )
    ''')

    # 2. scans tablosu: user_id sütunu eklenmiş haliyle oluşturma
    # Eğer scans tablosu yoksa oluştur, varsa var olan tabloya user_id ekle (yalnızca yoksa)
    c.execute('''
        CREATE TABLE IF NOT EXISTS scans (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            scan_id INTEGER,
            timestamp TEXT,
            target TEXT,
            tool TEXT,
            output TEXT,
            alerts_json TEXT,
            cvss REAL
            -- user_id ekleniyor aşağıda kontrol ile
        )
    ''')
    # Sütun var mı kontrolü
    c.execute("PRAGMA table_info(scans)")
    cols = [info[1] for info in c.fetchall()]  # info[1] sütun adı
    if 'user_id' not in cols:
        try:
            c.execute("ALTER TABLE scans ADD COLUMN user_id INTEGER")
        except Exception as e:
            print("scans tablosuna user_id eklenemedi:", e)

    # 3. schedules tablosu: user_id sütunu eklenmiş haliyle oluşturma
    c.execute('''
        CREATE TABLE IF NOT EXISTS schedules (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            target TEXT NOT NULL,
            tools TEXT NOT NULL,
            email TEXT,
            interval_minutes INTEGER NOT NULL,
            enabled INTEGER NOT NULL DEFAULT 1
            -- user_id ekleniyor aşağıda kontrol ile
        )
    ''')
    c.execute("PRAGMA table_info(schedules)")
    cols2 = [info[1] for info in c.fetchall()]
    if 'user_id' not in cols2:
        try:
            c.execute("ALTER TABLE schedules ADD COLUMN user_id INTEGER")
        except Exception as e:
            print("schedules tablosuna user_id eklenemedi:", e)

    conn.commit()
    conn.close()

def create_user(username, password):
    """
    Yeni kullanıcı oluşturur. username unique. password plaintext alınır, hashlenip saklanır.
    """
    password_hash = generate_password_hash(password)
    created_at = datetime.utcnow().isoformat()
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    try:
        c.execute("INSERT INTO users (username, password_hash, created_at) VALUES (?, ?, ?)",
                  (username, password_hash, created_at))
        conn.commit()
        user_id = c.lastrowid
    except sqlite3.IntegrityError:
        conn.close()
        return None  # username zaten var
    conn.close()
    return user_id

def verify_user(username, password):
    """
    Giriş yaparken kullanıcı adı ve parola kontrolü.
    Başarılıysa kullanıcı id döner, başarısızsa None döner.
    """
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT id, password_hash FROM users WHERE username = ?", (username,))
    row = c.fetchone()
    conn.close()
    if not row:
        return None
    user_id, password_hash = row
    if check_password_hash(password_hash, password):
        return user_id
    return None

def get_user_by_id(user_id):
    """
    Kullanıcı bilgisi alınabilir. Örneğin username.
    """
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT id, username, created_at FROM users WHERE id = ?", (user_id,))
    row = c.fetchone()
    conn.close()
    if not row:
        return None
    return {'id': row[0], 'username': row[1], 'created_at': row[2]}

def save_scan_result(scan_id, target, tool, output=None, alerts_json=None, cvss=0.0, user_id=None):
    """
    Sonuçları kaydeder. Eğer ZAP ise alerts_json parametresini, diğer araçlar için output parametresini kullan.
    user_id: integer; zorunlu. Hangi kullanıcıya ait olduğu bilgisi saklanır.
    """
    timestamp = datetime.utcnow().isoformat()
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    # scans tablosunda user_id sütunu olduğundan, insert ederken user_id de ekleyelim
    # Eğer sütun yoksa sorun olmaz çünkü init_db eklemiş olmalı
    c.execute(
        "INSERT INTO scans (scan_id, timestamp, target, tool, output, alerts_json, cvss, user_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
        (scan_id, timestamp, target, tool, output, alerts_json, cvss, user_id)
    )
    conn.commit()
    conn.close()

def get_user_all_results(user_id):
    """
    Kullanıcının tüm scan kayıtlarını getirir. Her satır dict:
    {
      'scan_id': ...,
      'timestamp': ...,
      'target': ...,
      'tool': ...,
      'output': ...,
      'alerts': [...],
      'cvss': ...
    }
    """
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute(
        "SELECT scan_id, timestamp, target, tool, output, alerts_json, cvss FROM scans WHERE user_id = ? ORDER BY timestamp ASC",
        (user_id,)
    )
    rows = c.fetchall()
    conn.close()
    results = []
    for r in rows:
        scan_id, timestamp, target, tool, output, alerts_json, cvss = r
        alerts = []
        if alerts_json:
            try:
                alerts = json.loads(alerts_json)
            except Exception:
                alerts = []
        results.append({
            'scan_id': scan_id,
            'timestamp': timestamp,
            'target': target,
            'tool': tool,
            'output': output,
            'alerts': alerts,
            'cvss': cvss
        })
    return results

def get_user_last_scan_results(user_id):
    """
    Kullanıcının en son scan_id'sine göre kayıtları getirir.
    """
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT MAX(scan_id) FROM scans WHERE user_id = ?", (user_id,))
    row = c.fetchone()
    conn.close()
    last_scan_id = row[0] if row else None
    if last_scan_id is None:
        return []
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute(
        "SELECT scan_id, timestamp, target, tool, output, alerts_json, cvss FROM scans WHERE user_id = ? AND scan_id = ? ORDER BY id ASC",
        (user_id, last_scan_id)
    )
    rows = c.fetchall()
    conn.close()
    results = []
    for r in rows:
        scan_id, timestamp, target, tool, output, alerts_json, cvss = r
        alerts = []
        if alerts_json:
            try:
                alerts = json.loads(alerts_json)
            except Exception:
                alerts = []
        results.append({
            'scan_id': scan_id,
            'timestamp': timestamp,
            'target': target,
            'tool': tool,
            'output': output,
            'alerts': alerts,
            'cvss': cvss
        })
    return results

# schedules tablosu için helper fonksiyonlar burada değil; bunları app.py içinde kullanacağız,
# çünkü schedules işlemlerinde user_id bilgisini session'dan alacağız

