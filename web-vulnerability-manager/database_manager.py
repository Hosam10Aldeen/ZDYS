# database_manager.py
import sqlite3
import json
from datetime import datetime

DB_PATH = 'database.db'

def init_db():
    """
    Veritabanı yoksa oluşturur. Bir defa çağırmak yeterlidir.
    """
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('''
        CREATE TABLE IF NOT EXISTS scans (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            scan_id INTEGER,
            timestamp TEXT,
            target TEXT,
            tool TEXT,
            output TEXT,
            alerts_json TEXT,
            cvss REAL
        )
    ''')
    conn.commit()
    conn.close()

def save_scan_result(scan_id, target, tool, output=None, alerts_json=None, cvss=0.0):
    """
    Sonuçları kaydeder. Eğer ZAP ise alerts_json parametresini, diğer araçlar için output parametresini kullan.
    - scan_id: dışarıda oluşturulan scan kimliği (örn. zaman damgası)
    - target: taranan URL veya IP
    - tool: 'nmap', 'nikto', 'wpscan', 'zap' vb.
    - output: diğer araçlar için düz metin çıktısı (string). ZAP için None bırak.
    - alerts_json: ZAP için json.dumps(alerts) ile oluşturulmuş string. Diğer araçlar için None.
    - cvss: float
    """
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    # Tabloyu oluştur (ilk çağırmada):
    c.execute('''
        CREATE TABLE IF NOT EXISTS scans (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            scan_id INTEGER,
            timestamp TEXT,
            target TEXT,
            tool TEXT,
            output TEXT,
            alerts_json TEXT,
            cvss REAL
        )
    ''')
    timestamp = datetime.utcnow().isoformat()
    c.execute(
        "INSERT INTO scans (scan_id, timestamp, target, tool, output, alerts_json, cvss) VALUES (?, ?, ?, ?, ?, ?, ?)",
        (scan_id, timestamp, target, tool, output, alerts_json, cvss)
    )
    conn.commit()
    conn.close()

def get_all_results():
    """
    Tüm kayıtları getirir. Her satır dict olarak döner:
    {
      'scan_id': ...,
      'timestamp': ...,
      'target': ...,
      'tool': ...,
      'output': ...,
      'alerts': [...],
      'cvss': ...
    }
    """
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT scan_id, timestamp, target, tool, output, alerts_json, cvss FROM scans ORDER BY timestamp ASC")
    rows = c.fetchall()
    conn.close()
    results = []
    for r in rows:
        scan_id, timestamp, target, tool, output, alerts_json, cvss = r
        alerts = []
        if alerts_json:
            try:
                alerts = json.loads(alerts_json)
            except Exception:
                alerts = []
        results.append({
            'scan_id': scan_id,
            'timestamp': timestamp,
            'target': target,
            'tool': tool,
            'output': output,
            'alerts': alerts,
            'cvss': cvss
        })
    return results

def get_last_scan_results():
    """
    scan_id değeri en büyük olan taramaya ait kayıtları getirir.
    Eğer birden fazla aynı scan_id varsa, hepsini alır.
    """
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT MAX(scan_id) FROM scans")
    row = c.fetchone()
    conn.close()
    last_scan_id = row[0] if row else None
    if last_scan_id is None:
        return []
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT scan_id, timestamp, target, tool, output, alerts_json, cvss FROM scans WHERE scan_id = ? ORDER BY id ASC", (last_scan_id,))
    rows = c.fetchall()
    conn.close()
    results = []
    import json
    for r in rows:
        scan_id, timestamp, target, tool, output, alerts_json, cvss = r
        alerts = []
        if alerts_json:
            try:
                alerts = json.loads(alerts_json)
            except Exception:
                alerts = []
        results.append({
            'scan_id': scan_id,
            'timestamp': timestamp,
            'target': target,
            'tool': tool,
            'output': output,
            'alerts': alerts,
            'cvss': cvss
        })
    return results
